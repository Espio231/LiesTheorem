import Mathlib.Algebra.Lie.Solvable
import Mathlib.Algebra.Lie.Weights.Linear
import BachelorProject.scratch

set_option autoImplicit false

open LieAlgebra


-- let k be a field of characteristic zero
variable {k : Type*} [Field k] [CharZero k] [IsAlgClosed k]
-- Let L be a Lie algebra over k
variable {L : Type*} [LieRing L] [LieAlgebra k L]
-- and let V be a finite-dimensional triangularizable k-representation of L
variable {V : Type*} [AddCommGroup V] [Module k V] [FiniteDimensional k V]
  [LieRingModule L V] [LieModule k L V] [Nontrivial V]

-- If `L` is nilpotent, we can find a non-zero eigenvector
theorem LieModule.exists_forall_lie_eq_smul' [LieAlgebra.IsNilpotent k L] :
    ∃ χ : Module.Dual k L, ∃ v : V, v ≠ 0 ∧ ∀ x : L, ⁅x, v⁆ = χ x • v := by
  suffices h : ∃ χ : L → k, weightSpace V χ ≠ ⊥ by
    obtain ⟨χ, hχ⟩ := h
    let χ' : weight k L V := ⟨χ, (finite_weightSpace_ne_bot k L V).mem_toFinset.mpr hχ⟩
    use weight.toLinear k L V χ'
    exact exists_forall_lie_eq_smul_of_weightSpace_ne_bot k L V χ hχ
  by_contra! contra
  simpa [contra] using iSup_weightSpace_eq_top k L V

open FiniteDimensional


-- We define the Submodules generated by repeatedly applying a linear map `f: V →ₗ[F] V` to a vector `v`
section

variable {F V : Type*} [Field F] [AddCommGroup V] [Module F V] [FiniteDimensional F V]
variable (v : V) (f : Module.End F V)
-- the Submodule generated by `v`, `f v`, `f f v`, ... , `f^[n-1] v`
abbrev preU (n : ℕ) : Submodule F V := Submodule.span F {v' : V | ∃ a < n, v' = (f^a) v}

theorem preU_zero_eq_bot : preU v f 0 = ⊥ := by
  rw [Submodule.span_eq_bot]
  intro x ⟨a, ha, _⟩
  contradiction

theorem preU_mono {a b : ℕ} (h : a ≤ b) : preU v f a ≤ preU v f b :=
  Submodule.span_mono (fun _ ⟨c, hc, hw⟩ ↦ ⟨c, lt_of_lt_of_le hc h, hw⟩)

theorem map_preU_le (n : ℕ) : Submodule.map f (preU v f n) ≤ preU v f (n + 1) := by
  rw [Submodule.map_span]
  apply Submodule.span_mono
  intro w ⟨z, ⟨m, hm, hz⟩, hw⟩
  use m + 1, Nat.add_lt_add_right hm 1
  rw [← hw, pow_succ, hz]
  rfl

def preU_map : ℕ →o Submodule F V where
  toFun := preU v f
  monotone' _ _ := preU_mono v f

abbrev U : Submodule F V := Submodule.span F (Set.range (fun (n : ℕ) ↦ (f^n) v))

theorem preU_le_U (n : ℕ) : preU v f n ≤ U v f := by
  apply Submodule.span_mono
  intro v' ⟨a, _, hv'⟩
  use a
  exact hv'.symm

theorem U_sup_preU : U v f = ⨆ k : ℕ, preU_map v f k := by
  apply LE.le.antisymm
  · rw [Submodule.span_le]
    intro v' ⟨a, hv'⟩
    apply Submodule.mem_iSup_of_mem (a + 1)
    apply Submodule.subset_span
    use a, (lt_add_one a), hv'.symm
  · rw [iSup_le_iff]
    exact preU_le_U v f

theorem U_eq_preU : ∃ N : ℕ, U v f = preU v f N := by
  apply Submodule.FG.stablizes_of_iSup_eq _ (preU_map v f)
  exact (U_sup_preU v f).symm
  exact IsNoetherian.noetherian (U v f)

theorem map_U_le_U: Submodule.map f (U v f) ≤ U v f := by
  rcases U_eq_preU v f with ⟨N, hN⟩
  nth_rewrite 1 [hN]
  apply le_trans' (preU_le_U v f (N + 1))
  exact map_preU_le v f N

theorem exists_hyperplane {n : ℕ} (hV : finrank F V = n + 1) (W : Submodule F V) (hW : finrank F V ≤ n):
  ∃ W' : Submodule F V, ∃ z : V, W ≤ W' ∧ W' ⊔ Submodule.span F {z} = ⊤ := by

  sorry


end


section

variable (A : LieIdeal k L) (χ : Module.Dual k L)

variable (k V)
-- the lie action of `L` on `V`
abbrev π (z : L) : Module.End k V := LieModule.toEndomorphism k L V z
variable {k V}

-- We define a submodule of V which is L-invariant
def altWeightSpace : Submodule k V where
  carrier := {v |∀ a ∈ A, ⁅a,v⁆ = (χ a)•v}
  add_mem' := by
    intro _ _ ha hb _ _
    rwa [lie_add, ha, hb, ← smul_add]
    assumption
  zero_mem' := by
    intro _ _
    rw [lie_zero, smul_zero]
  smul_mem' := by
    intro _ _ hx _ _
    rwa [lie_smul, hx, smul_comm]

theorem lemma2 (z w : L) (v : V) (n : ℕ)
    (h : π k V w (((π k V z) ^ n) v) - χ w • (((π k V z)^n) v) ∈ preU v (π k V z) n) :
  π k V w (((π k V z)^n) v) ∈ preU v (π k V z) (n + 1) := by
  let πz : Module.End k V := π k V z
  have t₁ : π k V w ((πz^n) v) =
      (π k V w ((πz^n) v) - χ w • ((πz^n) v) + χ w • ((πz^n) v)) := by simp
  rw [t₁]
  apply Submodule.add_mem
  · apply (preU_mono v πz n.le_succ)
    assumption
  · apply Submodule.smul_mem
    apply Submodule.subset_span
    use n
    simp


theorem lemma3 (z : L) {v : V} (hv : v ∈ altWeightSpace A χ) (n : ℕ) :
    ∀ w ∈ A, π k V w (((π k V z)^n) v) - χ w • (((π k V z)^n) v) ∈ preU v (π k V z) n := by
  induction' n with n ih
  · intro w hw
    simp [hv w hw]
  · intro w hw
    rw [pow_succ]
    dsimp
    rw [leibniz_lie, ← lie_smul, add_sub_assoc]
    apply Submodule.add_mem
    · exact lemma2 χ z ⁅w,z⁆ v n (ih ⁅w,z⁆ (lie_mem_left k L A w z hw))
    · rw [← lie_sub]
      apply map_preU_le
      use ⁅w, ((π k V z)^n) v⁆ - χ w • (((π k V z)^n) v)
      constructor
      exact ih w hw
      trivial

example (K M : Submodule k V) (g : V →ₗ[k] V) (h : Submodule.map g K ≤ M) : ∀ x ∈ K, g x ∈ M :=
  fun _ hx ↦ h (Submodule.mem_map_of_mem hx)


theorem U_A_stable (z w : L) (hw : w ∈ A) {v : V} (hv : v ∈ altWeightSpace A χ) :
  ∀ x ∈ (U v (π k V z)), (π k V w) x ∈ (U v (π k V z)):= by
  suffices h : Submodule.map (π k V w) (U v (π k V z)) ≤ (U v (π k V z)) by
    exact fun _ hx ↦ h (Submodule.mem_map_of_mem hx)
  rcases U_eq_preU v (π k V z) with ⟨N, hN⟩
  nth_rewrite 1 [hN]
  rw [Submodule.map_span, Submodule.span_le]
  intro x ⟨y, ⟨n, hn, hy⟩, hx⟩
  rw [← hx, hy, ← sub_add_cancel ((π k V w) ((π k V z ^ n) v)) (χ w • (((π k V z)^n) v))]
  apply Submodule.add_mem
  · apply preU_le_U v _ n
    apply lemma3 A χ z hv n w hw
  · apply preU_le_U v _ N
    apply Submodule.smul_mem
    apply Submodule.subset_span
    use n, hn


abbrev T (w : L) : Module.End k V := (π k V w)  - χ w • 1

variable (z w : L) {v : V}

theorem T_apply_succ  (hw : w ∈ A) (hv : v ∈ altWeightSpace A χ) (n : ℕ) :
  Submodule.map (T χ w) (preU v (π k V z) (n + 1)) ≤ preU v (π k V z) n:= by
  rw [LinearMap.map_span, T]
  apply Submodule.span_le.mpr
  intro x ⟨y, ⟨a, ha, hy⟩, hx⟩
  rw [← hx, hy]
  rw [LinearMap.sub_apply]
  apply preU_mono v (π k V z) ((Nat.le_of_lt_succ ha))
  exact lemma3 A χ z hv a w hw

theorem T_map_U (hw : w ∈ A) (hv : v ∈ altWeightSpace A χ) :
  ∀ x ∈ U v (π k V z), (T χ w) x ∈ U v (π k V z) := by
  intro x hx
  rcases U_eq_preU v (π k V z) with ⟨N, hN⟩
  apply preU_le_U _ _ N
  apply T_apply_succ A χ z w hw hv (N)
  use x
  constructor
  · apply preU_mono v (π k V z) (N.le_succ)
    rw [hN] at hx
    assumption
  · trivial


example (H K: Submodule k V) (f : Module.End k V) (h : Submodule.map f H ≤ K ) : ∀ x ∈ H, f x ∈ K :=
  λ x hx => h ⟨x, hx, rfl⟩

theorem T_something (hw : w ∈ A) (hv : v ∈ altWeightSpace A χ) (N: ℕ) :
  ∀ x ∈ (preU_map v (π k V z)) N, (T χ w ^ N) x = 0 := by
  induction' N with N ih
  · simp only [preU_map, Nat.zero_eq, OrderHom.coe_mk, preU_zero_eq_bot, Submodule.mem_bot,
    pow_zero, LinearMap.one_apply, imp_self, forall_const]
  · intro x hx
    rw [pow_succ', LinearMap.mul_apply]
    apply ih
    apply T_apply_succ A χ z w hw hv N
    use x, hx

theorem T_res_nilpotent (hw : w ∈ A) (hv : v ∈ altWeightSpace A χ) :
  IsNilpotent ((T χ w).restrict (T_map_U A χ z w hw hv)) := by
  rw [IsNilpotent_iff_of_FG]
  rintro ⟨x, hx⟩
  rw [U_sup_preU, Submodule.mem_iSup_of_chain] at hx
  rcases hx with ⟨N, hN⟩
  use N
  rw [LinearMap.pow_restrict]
  rw [Subtype.ext_iff, LinearMap.restrict_apply, ZeroMemClass.coe_zero]
  exact T_something A χ z w hw hv N x hN

example (H : Submodule k V) (f : Module.End k H) (h : H = ⊥) : f = 0 := by
  ext ⟨x, hx⟩
  rw [h] at hx
  simp at hx
  subst hx
  simp only [LinearMap.zero_apply, ZeroMemClass.coe_zero, ZeroMemClass.coe_eq_zero]
  exact f.map_zero

theorem trace_T_res_zero (hw : w ∈ A) (hv : v ∈ altWeightSpace A χ) :
  LinearMap.trace k (U v (π k V z)) ((T χ w).restrict (T_map_U A χ z w hw hv)) = 0 := by
  apply IsNilpotent.eq_zero
  exact LinearMap.isNilpotent_trace_of_isNilpotent (T_res_nilpotent A χ z w hw hv)

abbrev πaz_map_U {a : L} (ha : a ∈ A) (hv : v ∈ altWeightSpace A χ) :
  ∀ x ∈ U v (π k V z), π k V ⁅a,z⁆ x ∈ U v (π k V z):= by
  intro x hx
  apply U_A_stable A χ z ⁅a,z⁆ (lie_mem_left k L A a z ha) hv
  assumption

theorem trace_πaz {a : L} (ha : a ∈ A) (hv : v ∈ altWeightSpace A χ):
  LinearMap.trace k (U v (π k V z)) ((π k V ⁅a, z⁆).restrict (πaz_map_U A χ z ha hv))
    = χ ⁅a,z⁆ • (finrank k (U v (π k V z))) := by
  rw [← LinearMap.trace_id, ← LinearMap.map_smul, ← sub_eq_zero]
  rw [← LinearMap.map_sub]
  apply trace_T_res_zero A χ z ⁅a,z⁆ (lie_mem_left k L A a z ha) hv

@[simp]
theorem foo (w : V) (f : Module.End k V) : ⁅f, w⁆ = f w := by exact rfl

theorem foo2 (f g : Module.End k V) : ⁅f,g⁆ = f*g - g*f := by exact rfl

set_option pp.proofs.withType false

theorem trace_πaz_zero {a : L} (ha : a ∈ A) (hv : v ∈ altWeightSpace A χ):
  LinearMap.trace k (U v (π k V z)) ((π k V ⁅a, z⁆).restrict (πaz_map_U A χ z ha hv))
    = 0 := by
  -- have h : (π k V a).restrict (U_A_stable A χ z a ha hv) = 0 := by
  --   sorry
  have hzU : ∀ x ∈ U v (π k V z), (π k V z) x ∈ U v (π k V z) :=
    fun _ hx ↦ (map_U_le_U v (π k V z)) (Submodule.mem_map_of_mem hx)
  have hres : (π k V ⁅a, z⁆).restrict (πaz_map_U A χ z ha hv) =
    ⁅(π k V a).restrict (U_A_stable A χ z a ha hv),
    (π k V z).restrict hzU⁆ := by
    ext ⟨x, hx⟩
    simp
  rw [hres, foo2, map_sub, LinearMap.trace_mul_comm, sub_self]

theorem chi_az_zero {a : L} (ha : a ∈ A) (hv : v ∈ altWeightSpace A χ) (hv' : v ≠ 0):
    χ ⁅a,z⁆ = 0 := by
  have h := trace_πaz A χ z ha hv
  rw [trace_πaz_zero A χ z ha hv] at h
  suffices h' : finrank k ↥(U v (π k V z)) ≠ 0 by
    aesop
  have hvU : v ∈ U v (π k V z) := by
    apply Submodule.subset_span
    use 0
    simp only [pow_zero, LinearMap.one_apply]
  have U_nontrivial : Nontrivial (U v (π k V z)) := ⟨⟨v,hvU⟩,0, ?_⟩
  swap
  simp only [ne_eq, Submodule.mk_eq_zero, hv', not_false_eq_true]
  apply Nat.ne_of_lt'
  apply FiniteDimensional.finrank_pos


theorem altWeightSpace_lie_stable (hv : v ∈ altWeightSpace A χ):  ⁅z, v⁆ ∈ altWeightSpace A χ := by
  rcases eq_or_ne v 0 with (rfl | hv')
  · simp only [lie_zero, Submodule.zero_mem]
  · intro a ha
    have hzwv : ⁅⁅a, z⁆, v⁆ = χ ⁅a, z⁆ • v := hv ⁅a,z⁆ (lie_mem_left k L A a z ha)
    rw [leibniz_lie, hv a ha, hzwv]
    rw [chi_az_zero A χ z ha hv hv']
    simp only [zero_smul, lie_smul, zero_add]
--#lint
end

theorem isSolvable_of_le (R L : Type*) [CommRing R] [LieRing L] [LieAlgebra R L] {K K' : LieSubalgebra R L}
    [IsSolvable R K'] (h : K ≤ K') : IsSolvable R K :=
  Function.Injective.lieAlgebra_isSolvable (LieSubalgebra.inclusion_injective h)

theorem LieModule.exists_forall_lie_eq_smul_finrank [IsSolvable k L] [FiniteDimensional k L]
    {n : ℕ} (hdim : finrank k L = n) :
  ∃ χ : Module.Dual k L, ∃ v : V, v ≠ 0 ∧ ∀ x : L, ⁅x, v⁆ = χ x • v := by
  revert L
  induction' n with n ih
  · intro L _ _ _ _ _ _ hdim
    use 0
    rcases (exists_ne (0 : V)) with ⟨v, hv⟩
    use v, hv
    simp
    suffices h : ∀ (x : L), x = 0 by {simp only [h, zero_lie, forall_const]}
    rwa [← finrank_zero_iff_forall_zero (K := k)]
  · intro L _ _ _ _ _ _ hdim
    have hA : ∃(A : LieIdeal k L), ∃(z : L), finrank k A = n ∧
        A.toSubmodule ⊔ (Submodule.span k {z}) = ⊤ := by sorry
    rcases hA with ⟨A, z, hdimA, hdecomp⟩
    have hAsolv : IsSolvable k A := Function.Injective.lieAlgebra_isSolvable (f := LieIdeal.incl A)
      ((LieHom.ker_eq_bot _).mp (LieIdeal.ker_incl A))
    specialize ih hdimA
    rcases ih with ⟨χ, v, hv, hA⟩
    have χ' : Module.Dual k L :=
    --have πz_res : altWeightSpace A χ →ₗ⁅k⁆ altWeightSpace A χ := by sorry
    sorry

theorem LieModule.exists_forall_lie_eq_smul'' (g : LieSubalgebra k (Module.End k V)) {n : ℕ}
  (hn : finrank k g = n) [IsSolvable k g] :
  ∃ χ : Module.Dual k g, ∃ v : V, v ≠ 0 ∧ ∀ x : g, ⁅x, v⁆ = χ x • v := by
  revert g
  induction' n with n ih
  · intro g hn _
    use 0
    rcases (exists_ne (0 : V)) with ⟨v, hv⟩
    use v, hv
    intro x
    have xzero : x.val = 0 := by
      exact (Submodule.eq_bot_iff g.toSubmodule).mp (Submodule.finrank_eq_zero.mp hn) x (Submodule.coe_mem x)
    simp [xzero]
  · intro g hn hg
    -- have hgdecomp : ∃A : LieIdeal k g, ∃z : g, finrank k A = n ∧ A.toSubmodule ⊔ (Submodule.span k {z}) = ⊤
    --   := sorry
    -- rcases hgdecomp with ⟨A, z, hdimA, hgdecomp⟩
    -- sorry

    have hA : ∃ (A : LieSubalgebra k (Module.End k V)), (A ≤ g) ∧ (finrank k A = n)
    ∧ (∀ x y : Module.End k V, x ∈ A → y ∈ g → ⁅x,y⁆ ∈ A) := sorry
    rcases hA with ⟨A, hALEg, hdimA, hAgIdeal⟩
    have hz : ∃ (z : g), A.toSubmodule ⊔ (Submodule.span k {z.val}) = g := sorry
    rcases hz with ⟨z, hz⟩
    have h₁ : _ := by
      have : IsSolvable k A := isSolvable_of_le k (Module.End k V) hALEg
      apply ih A hdimA
    rcases h₁ with ⟨χ, v, hv, hweight⟩
    have hA' := by
      apply (LieSubalgebra.exists_nested_lieIdeal_coe_eq_iff hALEg).mpr
      intro x y hx hy
      rw [← neg_mem_iff (x := ⁅x,y⁆), lie_skew]
      exact hAgIdeal y x hy hx
    rcases hA' with ⟨A', hAA'⟩

    -- let πz_res : altWeightSpace A' χ →ₗ[k] altWeightSpace A' χ := sorry
    -- have hz_eigen : ∃ c, Module.End.HasEigenvalue (π k V z).restrict c := sorry

    sorry

-- But a better result, **Lie's theorem**, is true, namely:
-- If `L` is solvable, we can find a non-zero eigenvector
theorem LieModule.exists_forall_lie_eq_smul [IsSolvable k L] :
    ∃ χ : Module.Dual k L, ∃ v : V, v ≠ 0 ∧ ∀ x : L, ⁅x, v⁆ = χ x • v := by
  sorry
